<!DOCTYPE html>
<html>
<head>

  	<script src="js/jquery/jquery-2.0.3.min.js"></script>
  	<script src="js/jquery.svg/jquery.svg.min.js"></script>
  	<script src="js/jquery.svg/jquery.svgdom.min.js"></script>
	<script src="js/d3/d3.v3.min.js"></script>

	<script src="js/carto.net/timer.js"></script>
	<script src="js/carto.net/textbox.js"></script>

	<script src="js/common.js"></script>


  <script>


// usage: 
// $(document).filterNode("myapp:piechart")
// --> problem je v tom, ze se to porad tvari jako jmeno myapp:piechart v namespace svg

var _ = require("underscore")
var Base = require("basejs")
var PieChart = require("./js/piechart")(document)
var SVG = require("./js/svghelper")(document)
var svgsvg;

d3.ns.prefix.wow = wowNS

$(document).ready(function() {

	svgsvg = document.getElementById("svg")

	/* proc tohle nefunguje? */
	//var elements = document.getElementsByTagNameNS("http://example.org/myapp", 'piechart');

	/* this works! */
  /*
	var elements = document.getElementsByTagName("wow:piechart");

    console.log("Found elements: "+elements.length)
  */

  var widgetId = 1;

  var newWidgetId = function(prefix) {
    return (prefix || "wow-widget-")+(widgetId++)
  }

  var widgets = {}

  var Dim = Base.extend({
    constructor: function(w, h) {
      this.width = w
      this.height = h
    }
  })

  var widget = function(type, element, dim) {
    var id = newWidgetId()
    var group = SVG.attrs(SVG.group(), {
      "data-wow": type,
      "id": id
    })
    if(element.length) {
      // it is an array of elements!
      _.each(element, function(e) {
        group.appendChild(e)
      })
    } else {
      // it is only one element
      group.appendChild(element)
    }

    // in order to get bounding box, the node must be inserted in the DOM
    var bbox = SVG.measure(group)
    if(!dim) dim = { 
        width: bbox.x+bbox.width,
        height: bbox.y+bbox.height
    }

	// add text with size info and ID
	var txt = SVG.text(id+" ("+(dim.width).toFixed(1)+", "+(dim.height).toFixed(1)+")", {"x":dim.width, "y":10, "fill":"#333", "font-size":10, "font-family":"Verdana", "text-anchor":"end"})
	group.appendChild(txt)
	
    // add widget bounding box...
    var bbe = SVG.box(bbox)
    SVG.attr(bbe, "stroke", "blue");
    group.appendChild(bbe);   

    // add size box...
    var bbe = SVG.box(dim)
    SVG.attr(bbe, "stroke", "gray");
    group.appendChild(bbe);   

    // return widget object
    widgets[id] = {
      element: group,
      type: type,
      id: id,
      bounds: {x:bbox.x, y:bbox.y, width:bbox.width,height:bbox.height},
      dim: dim
    }
    return widgets[id]
  }

  /* copy contents from old element to new one */
  var moveChildren = function(from, to) {
	$(from).children().each(function() {
			$(to).append($(this))
		})
	}
	
  var widgetizers = {
    pieslice: null,
    piechart: function(element) {
      /* pie chart has several slices */
      var slices = $(element).filterNode("wow:pieslice")
      slices = _.map(slices, function(s) {
        var $s = $(s)
        return {label:$s.attr("label"), value:parseFloat($s.attr("value")), color:$s.attr("color")}
      })

      /* create pie chart */
      var newElement = PieChart(slices, 50, 50, 40, 110, 10)

        return widget("piechart", newElement)

    },
	box: function(element) {
		var width = $(element).attr("width") || 100
		var height = $(element).attr("height") || 100
		var fill = $(element).attr("fill") || "gray"
		var newElement = SVG.box({width:width,height:height,fill:fill})
        var ww = widget("box", newElement)
		moveChildren(element, ww.element)
		return ww
	},
	textbox: function(element) {
		var maxChars = $(element).attr("maxchars") || 20
		var newElement = SVG.group()
		var newId = newWidgetId("wow-textfield-")
		var text = $(element).text() || $(element).attr("value")
		var tb = new textbox({
			id: newId,
			parentNode: newElement,
			defaultVal: text, 
			maxChars: maxChars,
			x: 0,
			y: 0,
			boxWidth: 200,
			boxHeight: 30,
			textYOffset: 22,
			textStyles: {"font-family":"Arial,Helvetica","font-size":15,"fill":"dimgray"},
			boxStyles: {"fill":"white","stroke":"dimgray","stroke-width":1.5},
			cursorStyles: {"stroke":"red","stroke-width":1.5},
			selBoxStyles: {"fill":"blue","opacity":0.5},
			allowedChars: "[a-zA-Z ]",
			functionToCall: function(textboxId, value, changeType) { console.log(value); }
		});
		return widget("textbox", newElement)
	},
    grid: function(element) {
      // children are already widgetized...
      var uniformRows = ($(element).attr("uniformRows") == "true")
      var uniformColumns = ($(element).attr("uniformColumns") == "true")
      var rows = $(element).attr("rows") || 3
      var cols = $(element).attr("cols") || 3
      var halign = $(element).attr("halign") || "center"
      var valign = $(element).attr("valign") || "center"
	  // we must find topmost widgets...
	  var nodes = findWidgetizedNodes(element, [], true)
      subwidgets = _.map(nodes, function(e) {
        return widgets[e.getAttribute("id")]
      })
      var boxes = _.map(subwidgets, function(sw) {
        return { x:0, y:0, w:sw.dim.width, h:sw.dim.height }
      })
      var gg = SVG.group()
      var x = 0
      var y = 0
      var xmin=0,ymin=0,xmax=0,ymax=0
      var maxwidth=0, maxheight=0
	  var maxwidths = []
	  var maxheights = []
	  for(var row=0; row<rows; row++) maxheights[row] = 0
	  for(var col=0; col<cols; col++) maxwidths[col] = 0	  
	  var col = 0
	  var row = 0
      _.each(boxes, function(box) {
        maxwidth = Math.max(maxwidth, box.w)
        maxheight = Math.max(maxheight, box.h)
		if(maxwidths[col] < box.w) maxwidths[col] = box.w
		if(maxheights[row] < box.h) maxheights[row] = box.h
		col++;
		if(col == cols) {
		  col = 0;
		  row++;
		}
		if(row == rows) {
			return
		}
      })
	  col = 0
	  row = 0
	  var x0 = 0
	  var y0 = 0
	  var cellWidth
	  var cellHeight
      _.each(subwidgets, function(widget) {
	    x = x0
		y = y0
		cellWidth = uniformColumns ?  maxwidth : maxwidths[col]
		cellHeight = uniformRows ? maxheight : maxheights[row]
		gg.appendChild(SVG.box({x:x, y:y, width:cellWidth, height:cellHeight, fill:((col+row)%2)?"#ffd":"#dff", stroke:"none"}))
		if(valign == "center") {
			y += (cellHeight-widget.dim.height)/2
		} else if(valign == "bottom") {
			y += (cellHeight-widget.dim.height)
		}
		if(halign == "center") {
			x += (cellWidth-widget.dim.width)/2
		} else if(halign == "right") {
			x += (cellWidth-widget.dim.width)
		}
		col++;
		x0 += cellWidth
		if(col == cols) {
		  col = 0;
		  x0 = 0
		  row++;
		  y0 += cellHeight
		}
		if(row == rows) {
			return
		}
        var grp = SVG.group()
        grp.appendChild(widget.element)		
        SVG.transform(grp, "translate("+x+", "+y+")")
        gg.appendChild(grp)
      })
      return widget("group", gg, {width: cols*maxwidth, height: rows*maxheight})
	},
    flow: function(element) {
      // children are already widgetized...
      var direction = $(element).attr("direction") || "right"
      var anchor = $(element).attr("anchor") || "middle"
	  // we must find topmost widgets...
	  var nodes = findWidgetizedNodes(element, [], true)
      subwidgets = _.map(nodes, function(e) {
        return widgets[e.getAttribute("id")]
      })
      var boxes = _.map(subwidgets, function(sw) {
        return { x:0, y:0, w:sw.dim.width, h:sw.dim.height }
      })
      var gg = SVG.group()
      var x = 0
      var y = 0
      var xmin=0,ymin=0,xmax=0,ymax=0
      var maxwidth=0, maxheight=0
      _.each(boxes, function(box) {
        maxwidth = Math.max(maxwidth, box.w)
        maxheight = Math.max(maxheight, box.h)
      })
      var horiz = !(direction=="up" || direction=="down")
      // apply anchor...
      _.each(boxes, function(box) {
        if(horiz) {
          // set y coordinates
          var y=0
          if(anchor=="bottom") {
            y=maxheight-box.h
          } else if(anchor=="middle") {
            y=(maxheight-box.h)/2
          }
          box.y = y
        } else {
          // set x coordinates
          var x=0
          if(anchor=="right") {
            x=maxwidth-box.w
          } else if(anchor=="middle") {
            x=(maxwidth-box.w)/2
          }
          box.x = x
        }
      })
      // apply direction...
      _.each(boxes, function(box) {
        if(direction=="right") {
          box.x = x
          x += box.w
          xmax = x
          ymax = Math.max(ymax, box.h)
        } else if(direction=="left") {
          x -= box.w
          box.x = x
          xmin = x
          ymax = Math.max(ymax, box.h)
        } else if(direction=="up") {
          y -= box.h
          box.y = y
          ymin = y
          xmax = Math.max(xmax, box.w)
        } else if(direction=="down") {
          box.y = y
          y += box.h
          ymax = y
          xmax = Math.max(xmax, box.w)
        } 
      })
      // lay out widgets...
      _.each(subwidgets, function(widget, i) {
        var grp = SVG.group()
        grp.appendChild(widget.element)
        // do layout...
        var box = boxes[i]
        SVG.transform(grp, "translate("+box.x+", "+box.y+")")
        gg.appendChild(grp)
      })
      SVG.transform(gg, "translate("+(-xmin)+","+(-ymin)+")")
      return widget("flow", gg, {width: xmax-xmin, height: ymax-ymin})
    }
  }

  var makeWidget = function(element) {
    /* if the widget has subwidgets, create them... */
    widgetize(element)
	/* create the widget */
    var type = element.nodeName.split(":")[1]
    var widgetizer = widgetizers[type]
    if(widgetizer) {
      /* we can run widgetizer on an element... */
      var output = widgetizer(element)
      if(output) {        
        // replace element with output
        $(element).replaceWith(output.element)
        // console.log(output) -> this causes error under node=webkit on Windows
        return output;
      }
    } else {
      console.warn("Unknown widget type: "+type)
      return null
    }
  }


  var findWidgetizedNodes = function(node, inNodes, childrenOnly) {
	return findTopmostNodes(node, inNodes, childrenOnly, function(node) {
		return !!$(node).attr("data-wow")
	})
  }
  
  var findWowNodes = function(node, inNodes, childrenOnly) {
	return findTopmostNodes(node, inNodes, childrenOnly, function(node) {
		return node.nodeName.startsWith("wow:")
	})
  }
  
  /* make widgets from node's descendants... */
  var widgetize = function(node) {
    var node = node || document
	var nodes = findWowNodes(node, [], true)
    _.each(nodes, makeWidget)
  }

  /* widgetize the entire page */
  widgetize()

  // search for widgetized elements: $("[data-wow]")

})
	</script>
</head>
<body>

<h1>My first SVG</h1>

<svg 
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:wow="http://example.org/wow"
    xmlns:xlink= "http://www.w3.org/1999/xlink"
    unselectable="on" 
    style="-webkit-user-select: none;"
    id="svg"
	tabindex='1'
    >
<image xlink:href="icons/SVG/accessibility.svg" x="300" y="100" height="100" width="100"/>

 <defs>
    <pattern id="checkerPattern" width="80" height="80"
      patternUnits="userSpaceOnUse">

      <rect fill="red" fill-opacity="0.2" x="0" y="0" width="40" height="40" />
      <rect fill="blue" fill-opacity="0.2" fill="blue" x="40" y="0" width="40" height="40" />
      <rect fill="blue" fill-opacity="0.2" x="0" y="40" width="40" height="40" />
      <rect fill="red" fill-opacity="0.2" x="40" y="40" width="40" height="40" />


    </pattern>
  </defs>

  <g transform="translate(50,50)">
    <rect fill="url(#checkerPattern)" x="0"
      y="0" width="400" height="400" />
  </g>


<!-- TODO: nested flows do not work properly... -->
<wow:grid cols="2"rows="3" valign="center" halign="center" uniformColumns="false" uniformRows="true">
    <wow:piechart name="foo" title="Sales by Region">
      <wow:pieslice label="Northern Region" value="1.23" color="blue"/>
      <wow:pieslice label="Eastern Region" value="2.53" color="red"/>
      <wow:pieslice label="Southern Region" value="3.89" color="green"/>
      <wow:pieslice label="Western Region" value="2.04" color="yellow"/>
    </wow:piechart>
<wow:textbox maxchars=30>Hello, SVG!</wow:textbox>

    <wow:piechart name="bar" title="Sales by Region">
      <wow:pieslice label="Python" value="1.23" color="blue"/>
      <wow:pieslice label="Java" value="2.53" color="red"/>
      <wow:pieslice label="C++" value="2" color="green"/>
    </wow:piechart>
	<wow:box width=300 height=60 fill="red"></wow:box>
<wow:flow direction="right" anchor="top">
	<wow:box width=200 height=200 fill="orange">

<rect x="20" y="20" width="60" height="60" fill="blue">
  <animateTransform attributeType="xml"
                    attributeName="transform"
                    type="rotate"
                    from="0 50 50"
                    to="360 50 50"
                    dur="4s"
                    repeatCount="indefinite"/>
</rect>  

	</wow:box>
	<wow:box width=150 height=140 fill="cyan"></wow:box>
</wow:flow>

    <wow:piechart name="bar" title="Sales by Region">
      <wow:pieslice label="Python" value="1.23" color="blue"/>
      <wow:pieslice label="Java" value="2.53" color="red"/>
      <wow:pieslice label="C++" value="2" color="green"/>
      <wow:pieslice label="C++" value="2" color="yellow"/>
      <wow:pieslice label="C++" value="2" color="purple"/>
      <wow:pieslice label="C++" value="2" color="salmon"/>
    </wow:piechart>
</wow:grid>



<g id="tempgroup" style="display:none;"></g>


<!-- alas, transform attribute does not work well with foreignObject forms -->
<!-- as well as wrapping it into svg element... -->
<g>
    <foreignObject x="350" y="50" width="200" height="150">
        <body xmlns="http://www.w3.org/1999/xhtml">
            <form>
                <input id="inner1" type="text"/>
                <input id="inner2" type="text"/>
            </form>
        </body>
    </foreignObject>
    <circle cx="360" cy="80" r="30" fill="#00ff00" fill-opacity="0.5"/>
</g>



</svg>




  <script>

$(document).ready(function(){

$("#inner1").change(function() {
  alert($(this).val())
})



function init(svg){
          
}

  
  $('#svg').svg({onLoad: init, settings: {
         //viewBox: '0 0 400 200',
         version: '1.1'
          }
  });

  
});
  
  </script>
</body>
</html>
